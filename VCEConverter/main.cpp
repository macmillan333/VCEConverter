#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
using namespace std;
//#include <QCoreApplication>
#include "structss.h"
#include "string.h"
#include "stdio.h"
#include <stdlib.h>
#include <string>
#include <sstream>

#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb/stb_image_write.h"

#define nullptr NULL

char title_text[]="VCE2STR converter\n";
char readme[]="The Vce/vci file format is used for UI and animations in old games.\n\
The str format comes originally from ez2dj \n\
\n\
USAGE: vceconverter -m -b -c file1.vce (file2.vce) (...) \n\
Parameters: -m : Just decode a file\n\
-b : change color blend to make rostrviewer work.\n\
-c : crop images that are not used in their entirely.\n\
valid input files: vce or vci (autodetected)\n";

class anikey{   //(aka key frame)
public:
    anikey_t data;
    anikey *next;

    anikey() : data(), next(nullptr) { }

    anikey* getlast () {
        //find last node
        anikey *temp = this;
        while (temp->next!=nullptr) {
            temp=temp->next;
        }
        return temp;
    }

    static void addafterlast(anikey *a){ //create and link node
        anikey *last = new anikey();
        a->getlast()->next=last;
    }
};

class texture {
public:
    texture_t data;
    texture *next;

    texture() : data(), next(nullptr) { }

    texture* getlast () {
        //find last node
        texture *temp = this;
        while (temp->next!=nullptr) {
            temp=temp->next;
        }
        return temp;
    }

    static void addafterlast(texture *a){ //create and link node
        texture *last = new texture();
        a->getlast()->next=last;
    }
};

class layer {
public:
    char vci_layer_data[0x5c];
    unsigned long texcnt;
    texture firsttex;
    layer *next;
    unsigned long anikeynum=0;
    anikey firstanikey;

    layer() : vci_layer_data(), texcnt(0), next(nullptr) { }

    layer* getlast () {
        //find last node
        layer *temp = this;
        while (temp->next!=nullptr) {
            temp=temp->next;
        }
        return temp;
    }

    static void addafterlast(layer *a){ //create and link node
        layer* last = new layer();
        a->getlast()->next=last;
    }
};

class vcefile {

public:
    header_t header;
    layer firstlayer;

    vcefile() : header(), firstlayer() { }
};

void tex2bmp(char *filename){

    FILE *batfile,*tmp;
    char stringg[200];
    const char bat_prog[]="\
:: auto generated by vceconverter\n\
:: Change the Image Magick path if you need.\n\
:: \n:: \n@echo off\n\
\"%%PROGRAMFILES(X86)%%\\ImageMagick-7.0.8-Q16\\magick\" %%1 ( -clone 0 \
-background #ff00ff ) +swap -background #ff00ff -layers merge +repage \
-define bmp3:alpha=false BMP3:%%1.bmp\n";

    //make a bat if there is none
    tmp=fopen(".\\img2bmp.bat","r");
    if (tmp==NULL) {
        batfile = fopen ("img2bmp.bat","w") ;
        fprintf(batfile,bat_prog);
        fflush(batfile);
        fclose(batfile);
        printf("\nCreated bat file. Edit it to change Image Magick path if necessary.\n");
    } else {
        fclose(tmp);
    }

    //create bmp, executing the .bat
    strcpy(stringg,filename);
    strcat(stringg,".bmp");
    tmp=fopen(stringg,"r");
    if (tmp==NULL) {
        strcpy(stringg,"img2bmp.bat ");
        strcat(stringg,filename);
        system(stringg);
        printf("(converting)");
    } else {
        fclose(tmp);
    }
}

int vce2str(const std::string&,int,int,int);
void unmask_vc(char *);
void printvcq();

FILE *infile;
int just_mask=0,masked,vce,vci,vcq,fix_blend=0,crop_images=0;

int main(int argc, char *argv[])
{
    int argcindex=1;

    unsigned char stringg[100];

    if (argc == 1) {	//no parameter, print help
        printf("%s",title_text);
         printf("%s",readme);
         return -1;

    } else { //parse params
        printf("%s",title_text);

        while (argcindex<argc) {
            if (argv[argcindex][0]=='-') {
                if (strcmp(argv[argcindex],"-m")==0) just_mask=1;
                if (strcmp(argv[argcindex],"-b")==0) fix_blend=1;
                if (strcmp(argv[argcindex], "-c") == 0) crop_images = 1;
            } else {

                infile = fopen (argv[argcindex],"rb");
                if (infile==nullptr) {
                    printf("Error opening file %s\n",argv[argcindex]);
                    return -1;
                } else {    //check format
                    printf("Opened %s \n",argv[argcindex]);
                    fread(stringg,sizeof(char),0x40,infile);
                    masked=0;
                    vce=0;
                    vci=0;
                    vcq=0;
                    if (stringg[0]=='V'&&stringg[1]=='C'&&stringg[2]=='M') { //vce/i
                        printf("Type: ");
                        if (stringg[13]!=0) {
                            masked=1;
                        } else {
                            printf("Unmasked ");
                        }
                        char a;
                        a=argv[argcindex][strlen(argv[argcindex])-1];
                        if ( a=='I' || a=='i' ) {
                            vci=1;
                            printf("VCI file\n");
                        } else {
                            vce=1;
                            printf("VCE file\n");
                        }

                        rewind(infile);

                        if (just_mask==0) {
                            if (masked==1) unmask_vc(argv[argcindex]);
                            int returnvalue = vce2str(argv[argcindex],vci,fix_blend,crop_images);
                            if (returnvalue != 0) return returnvalue;
                            if (masked==1) unmask_vc(argv[argcindex]);//re mask
                        } else {
                            unmask_vc(argv[argcindex]);//mask
                        }

                    } else {    //not vce nor vci
                        if (stringg[0]=='V'&&stringg[1]=='C'&&stringg[2]=='Q') {
                            printf("Type: VCQ file\n");
                            printvcq();
                        } else {
                            printf("Unknown format\n");
                        }
                    }
                }
                fclose(infile);
            }
            argcindex++;
        }
    }

    return 0;
}

std::string maybecropimage(const std::string& dir, const texture_t& tex) {
    std::string filename(tex.texname);

    // Parse tex coords
    int16_t x1 = *(reinterpret_cast<const int16_t*>(tex.texcoord + 16));
    int16_t y1 = *(reinterpret_cast<const int16_t*>(tex.texcoord + 18));
    int16_t x2 = *(reinterpret_cast<const int16_t*>(tex.texcoord + 20));
    int16_t y2 = *(reinterpret_cast<const int16_t*>(tex.texcoord + 22));
    if (x1 > x2)
    {
        int16_t tmp = x1;
        x1 = x2;
        x2 = tmp;
    }
    if (y1 > y2)
    {
        int16_t tmp = y1;
        y1 = y2;
        y2 = tmp;
    }
    printf("tex coords: %d %d %d %d", x1, y1, x2, y2);
    if (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) return filename;

    // Generate filename
    size_t lastdot = filename.find_last_of('.');
    std::string basename = filename.substr(0, lastdot);
    std::string extension = filename.substr(lastdot + 1);
    std::stringstream outputnamestream;
    outputnamestream << basename << x1 << y1 << x2 << y2 << '.' << extension;
    std::string outputname = outputnamestream.str();
    std::string fulloutputpath = dir + '\\' + outputname;
    printf("\nWill crop to: %s", outputname.c_str());

    // Read input
    std::string fullinputpath = dir + '\\' + filename;
    int x, y, channels;
    unsigned char* imagedata = stbi_load(fullinputpath.c_str(),
        &x, &y, &channels, 0);
    if (imagedata == nullptr) {
        printf("\n%s\n", stbi_failure_reason());
        exit(-1);
    }

    // Allocate cropped image data
    int outputsize = (x2 - x1) * (y2 - y1) * channels;
    unsigned char* outputdata = (unsigned char*)malloc(outputsize);
    int outputptr = 0;

    // Perform crop
    for (int row = y1; row < y2; row++)
    {
        for (int col = x1; col < x2; col++)
        {
            for (int channel = 0; channel < channels; channel++)
            {
                outputdata[outputptr] = imagedata[(row * y + col) * channels + channel];
                outputptr++;
            }
        }
    }

    // Write to file
    if (stbi_write_png(fulloutputpath.c_str(), x2 - x1, y2 - y1, channels, outputdata, /*stride_in_bytes=*/(x2 - x1) * channels) == 0) {
        printf("\nFailed to write output file\n");
        exit(-1);
    }

    // Free
    free(outputdata);
    stbi_image_free(imagedata);
    return outputname;
}

int vce2str(const std::string& path,int vci,
    int fix_blend, int crop_images) {
    // Parse path
    size_t lastslash = path.find_last_of("/\\");
    size_t lastdot = path.find_last_of('.');
    std::string dir = path.substr(0, lastslash);
    std::string basename = path.substr(lastslash + 1,
        lastdot - lastslash - 1);

    vcefile vce;
    std::string outpath = dir + '\\' + basename + ".str";
    FILE* outfile = fopen (outpath.c_str(), "wb");

    if (outfile==nullptr) {
        printf("Error writing file\n");
        return -1;
    }

    fread(&vce.header, sizeof(struct header_s), 1, infile);

    fputs("STRM",outfile);
    fputc(0x94,outfile);
    fputc(0,outfile);
    fputc(0,outfile);
    fputc(0,outfile);
    fwrite(&vce.header.fps,sizeof (unsigned long),1,outfile);
    fwrite(&vce.header.maxkey,sizeof (unsigned long),1,outfile);
    fwrite(&vce.header.layernum,sizeof (unsigned long),1,outfile);
    fwrite(&vce.header.none2,sizeof (unsigned long),3,outfile);
    fwrite(&vce.header.none2,sizeof (unsigned long),1,outfile);

    printf("Total layers: %lu . Max frame time: %lu .\n",vce.header.layernum,vce.header.maxkey);

    int i;

    //read layers
    for (i=0 ; i < vce.header.layernum ; i++) {

        printf("Layer %d ",i);

        if (i!=0) layer::addafterlast(&vce.firstlayer) ; //new layer and link it
        layer* lastlayer = vce.firstlayer.getlast();

        if (vci==1) fread(lastlayer->vci_layer_data, sizeof(char), 0x5c, infile);
        if (strcmp(lastlayer->vci_layer_data,"#MOVIE#")==0) printf("\"movie\"");

        fread(&(lastlayer->texcnt), sizeof(unsigned long), 1, infile);    //texcnt
        fwrite(&(lastlayer->texcnt),sizeof (unsigned long),1,outfile);

        printf(": %lu texture(s) : ",lastlayer->texcnt);
        //read textures of layer
        int j;

        char strtexname[0x80];
        for (j=0;j<0x80;j++) strtexname[j]=0;

        for (j=0 ; j < lastlayer->texcnt ; j++) {
            if (j!=0) texture::addafterlast(&(lastlayer->firsttex)) ; //create tex and chain it
            texture* lasttex = lastlayer->firsttex.getlast();

            fread(&(lasttex->data), sizeof(struct texture_s), 1, infile);
            printf("%s ",lasttex->data.texname);
            if (crop_images == 1){
                std::string maybecroppedimagename = 
                    maybecropimage(dir, lasttex->data);
                strcpy(strtexname, maybecroppedimagename.c_str());
            }
            else {
                strcpy(strtexname, lasttex->data.texname);
            }
            fwrite(strtexname, 0x64, 1, outfile);
            //store texcoord at last 1Ch bytes
            fwrite(lasttex->data.texcoord, 0x1c, 1, outfile);
        }

        //anikeynum
        fread(&(lastlayer->anikeynum), sizeof(unsigned long), 1, infile);
        fwrite(&(lastlayer->anikeynum),sizeof (unsigned long),1,outfile);
        printf("\n(Key)Frame(s): %lu \n",lastlayer->anikeynum);

        //read anikeys of layer
        for (j=0 ; j < lastlayer->anikeynum ; j++) {
            if (j!=0) anikey::addafterlast(&(lastlayer->firstanikey)) ; //create anikey and chain it
            anikey* lastkey = lastlayer->firstanikey.getlast();

            fread(&(lastkey->data), sizeof(struct anikey_s), 1, infile);
            if (fix_blend==1) {
                unsigned long *sourceBlend= &(lastkey->data.blend[0]);
                unsigned long *destBlend= &(lastkey->data.blend[1]);
                if (  (*destBlend)<3 && (*sourceBlend)<3 ) {
                        *sourceBlend=1;
                        *destBlend=2;
                    }
            }
            //fix frametype
            unsigned long *frameType= &(lastkey->data.frameType);
            if (((*frameType)&1)==0) {
                *frameType=0;
            } else {
                *frameType=1;
            }
            fwrite(&(lastkey->data), sizeof(struct anikey_s), 1, outfile);
        }

    }


    fflush(outfile);
    fclose(outfile);

    return 0;
}

void unmask_vc(char *path){

    #define MASK_LENGTH 256
    const unsigned char mask[] = {
        247 ,77 ,219 ,74 ,220 ,102 ,240 ,83 ,197 ,127 ,233 ,28 ,138 ,48 ,166 ,5 ,147 ,41 ,191 ,46 ,184 ,2 ,148 ,55 ,161 ,27 ,141 ,0 ,150 ,44 ,186 ,25 ,143 ,53 ,163 ,50 ,164 ,30 ,136 ,43 ,189 ,7 ,145 ,100 ,242 ,72 ,222 ,125 ,235 ,81 ,
        199 ,86 ,192 ,122 ,236 ,79 ,217 ,99 ,245 ,200 ,94 ,228 ,114 ,209 ,71 ,253 ,107 ,250 ,108 ,214 ,64 ,227 ,117 ,207 ,89 ,172 ,58 ,128 ,22 ,181 ,35 ,153 ,15 ,158 ,8 ,178 ,36 ,135 ,17 ,171 ,61 ,144 ,6 ,188 ,42 ,137 ,31 ,165 ,51 ,162 ,
        52 ,142 ,24 ,187 ,45 ,151 ,1 ,244 ,98 ,216 ,78 ,237 ,123 ,193 ,87 ,198 ,80 ,234 ,124 ,223 ,73 ,243 ,101 ,88 ,206 ,116 ,226 ,65 ,215 ,109 ,251 ,106 ,252 ,70 ,208 ,115 ,229 ,95 ,201 ,60 ,170 ,16 ,134 ,37 ,179 ,9 ,159 ,14 ,152 ,34 ,
        180 ,23 ,129 ,59 ,173 ,32 ,182 ,12 ,154 ,57 ,175 ,21 ,131 ,18 ,132 ,62 ,168 ,11 ,157 ,39 ,177 ,68 ,210 ,104 ,254 ,93 ,203 ,113 ,231 ,118 ,224 ,90 ,204 ,111 ,249 ,67 ,213 ,232 ,126 ,196 ,82 ,241 ,103 ,221 ,75 ,218 ,76 ,246 ,96 ,195 ,85 , 239, 121, 140, 26, 160, 54, 149,
        3 ,185 , 47 ,190 ,40 ,146 ,4 ,167 ,49 ,139 ,29 ,176 ,38 ,156 ,10 ,169 ,63 ,133 ,19 ,130 ,20 ,174 ,56 ,155 ,13 ,183 ,33 ,212 ,66 ,248 ,110 ,205 ,91 ,225 ,119 ,230 ,112 ,202 ,92 ,255 ,105 ,211 ,69 ,120 ,238 ,84 ,194 ,97
    };

    int c, i, k_pos,header;
    char *buf=NULL;
    long int size,f_pos=0;

    FILE *f;

    f=infile;
    rewind(f);

    //copy file to buf
    fseek(f, 0, SEEK_END);
    size=ftell(f);
    buf=new char[size];
    //malloc(sizeof(char)*size);
    rewind(f);
    while (1) {
        i = fgetc(f);
        if (i==EOF) break;
        buf[f_pos]=i;
        f_pos++;
    }
    fclose(f);
    infile = fopen (path,"wb"); //reopen file

    header= 8 ;	//preserve the header "VC*F\0\x01\x02\0"
    k_pos=0;
    f_pos=0;
    while (1) {	//for every byte
        i=buf[f_pos];
        if (header !=0) {	//preserve header bytes
            header--;
            c = i;
        } else {
                c = i ^ mask[k_pos];	//xor the byte with the mask
        }

        fputc(c,f); //write byte to file

        k_pos++;
        if (k_pos==MASK_LENGTH) {	//loop the mask index
            k_pos=0;
        }

        f_pos++;
        if (f_pos==size) break; //if end of file
    }

    delete[] buf;
    fflush(f);
    fclose(f);
    infile = fopen (path,"rb"); //reopen file

}

void printvcq(){



}
